.version 2.0
.target sm_10, map_f64_to_f32

// shader: MESA_SHADER_MISS
// inputs: 0
// outputs: 0
// uniforms: 0
// ubos: 1
// shared: 0
// decl_function main (0 params)
.entry MESA_SHADER_MISS_func1_main () {
	.reg .b64 %Ray;
	rt_alloc_mem %Ray, 36, 32; // decl_var shader_call_data INTERP_MODE_NONE RayPayload Ray


	.reg .u64 %temp_u64;
	.reg .u32 %temp_u32;
	.reg .f32 %temp_f32;
	.reg .pred %temp_pred;
	.reg .f32 %const1_f32;
	mov.f32 %const1_f32, 0F3f800000;

	.reg .f32 %const0_f32;
	mov.f32 %const0_f32, 0F00000000;

	.reg .u32 %const0_u32;
	mov.u32 %const0_u32, 0;

	.reg .u16 %const1_u16;
	mov.u16 %const1_u16, 1;

	// start_block block_0:
	// preds: 
	.reg .f32 %ssa_0_0;
	.reg .f32 %ssa_0_1;
	.reg .f32 %ssa_0_2;
	.reg .f32 %ssa_0_3;
	mov.f32 %ssa_0_0, 0F00000000;
	mov.f32 %ssa_0_1, 0F00000000;
	mov.f32 %ssa_0_2, 0F00000000;
	mov.f32 %ssa_0_3, 0Fbf800000;
		// vec4 32 ssa_0 = load_const (0x00000000 /* 0.000000 */, 0x00000000 /* 0.000000 */, 0x00000000 /* 0.000000 */, 0xbf800000 /* -1.000000 */)

	.reg .f32 %ssa_1;
	mov.f32 %ssa_1, 0Fbf800000; // vec1 32 ssa_1 = load_const (0xbf800000 /* -1.000000 */)
	.reg .b32 %ssa_1_bits;
	mov.b32 %ssa_1_bits, 0Fbf800000;

	.reg .f32 %ssa_2_0;
	.reg .f32 %ssa_2_1;
	.reg .f32 %ssa_2_2;
	.reg .f32 %ssa_2_3;
	mov.f32 %ssa_2_0, 0F3f800000;
	mov.f32 %ssa_2_1, 0F3f800000;
	mov.f32 %ssa_2_2, 0F3f800000;
	mov.f32 %ssa_2_3, 0F00000000;
		// vec3 32 ssa_2 = load_const (0x3f800000 /* 1.000000 */, 0x3f800000 /* 1.000000 */, 0x3f800000 /* 1.000000 */)

	.reg .f32 %ssa_3;
	mov.f32 %ssa_3, 0F3f800000; // vec1 32 ssa_3 = load_const (0x3f800000 /* 1.000000 */)
	.reg .b32 %ssa_3_bits;
	mov.b32 %ssa_3_bits, 0F3f800000;

	.reg .f32 %ssa_4;
	mov.f32 %ssa_4, 0F00000000; // vec1 32 ssa_4 = load_const (0x00000000 /* 0.000000 */)
	.reg .b32 %ssa_4_bits;
	mov.b32 %ssa_4_bits, 0F00000000;

	.reg .b64 %ssa_5;
	load_vulkan_descriptor %ssa_5, 0, 3, 6; // vec2 32 ssa_5 = intrinsic vulkan_resource_index (%ssa_4) (0, 3, 6) /* desc_set=0 */ /* binding=3 */ /* desc_type=UBO */

	.reg .b64 %ssa_6;
	mov.b64 %ssa_6, %ssa_5; // vec2 32 ssa_6 = intrinsic load_vulkan_descriptor (%ssa_5) (6) /* desc_type=UBO */

	.reg .b64 %ssa_7;
	mov.b64 %ssa_7, %ssa_6; // vec2 32 ssa_7 = deref_cast (UniformBufferObjectStruct *)ssa_6 (ubo UniformBufferObjectStruct)  /* ptr_stride=0, align_mul=0, align_offset=0 */

	.reg .b64 %ssa_8;
	add.u64 %ssa_8, %ssa_7, 0; // vec2 32 ssa_8 = deref_struct &ssa_7->Camera (ubo UniformBufferObject) /* &((UniformBufferObjectStruct *)ssa_6)->Camera */

	.reg .b64 %ssa_9;
	add.u64 %ssa_9, %ssa_8, 284; // vec2 32 ssa_9 = deref_struct &ssa_8->HasSky (ubo uint) /* &((UniformBufferObjectStruct *)ssa_6)->Camera.HasSky */

	.reg  .u32 %ssa_10;
	ld.global.u32 %ssa_10, [%ssa_9]; // vec1 32 ssa_10 = intrinsic load_deref (%ssa_9) (0) /* access=0 */

	.reg .pred %ssa_11;
	setp.ne.s32 %ssa_11, %ssa_10, %ssa_4_bits; // vec1  1 ssa_11 = ine ssa_10, ssa_4

	// succs: block_1 block_2 
	// end_block block_0:
	//if
	@!%ssa_11 bra else_5;
	
		// start_block block_1:
		// preds: block_0 
		.reg .f32 %ssa_12_0;
		.reg .f32 %ssa_12_1;
		.reg .f32 %ssa_12_2;
		.reg .f32 %ssa_12_3;
		.reg .b64 %ssa_12_address;
		load_ray_world_direction %ssa_12_address; // vec3 32 ssa_12 = intrinsic load_ray_world_direction () ()
		ld.global.f32 %ssa_12_0, [%ssa_12_address + 0];
		ld.global.f32 %ssa_12_1, [%ssa_12_address + 4];
		ld.global.f32 %ssa_12_2, [%ssa_12_address + 8];
		ld.global.f32 %ssa_12_3, [%ssa_12_address + 12];

		.reg .f32 %ssa_13;
		mul.f32 %ssa_13, %ssa_12_0, %ssa_12_0; // vec1 32 ssa_13 = fmul ssa_12.x, ssa_12.x

		.reg .f32 %ssa_14;
		mul.f32 %ssa_14, %ssa_12_1, %ssa_12_1; // vec1 32 ssa_14 = fmul ssa_12.y, ssa_12.y

		.reg .f32 %ssa_15;
		mul.f32 %ssa_15, %ssa_12_2, %ssa_12_2; // vec1 32 ssa_15 = fmul ssa_12.z, ssa_12.z

		.reg .f32 %ssa_16_0;
		.reg .f32 %ssa_16_1;
		.reg .f32 %ssa_16_2;
		.reg .f32 %ssa_16_3;
		mov.f32 %ssa_16_0, %ssa_13;
		mov.f32 %ssa_16_1, %ssa_14;
		mov.f32 %ssa_16_2, %ssa_15; // vec3 32 ssa_16 = vec3 ssa_13, ssa_14, ssa_15

		.reg .f32 %ssa_17;
		add.f32 %ssa_17, %ssa_16_0, %ssa_16_1;
		add.f32 %ssa_17, %ssa_17, %ssa_16_2; // vec1 32 ssa_17 = fsum3 ssa_16

		.reg .f32 %ssa_18;
		rsqrt.approx.f32 %ssa_18, %ssa_17;	// vec1 32 ssa_18 = frsq ssa_17

		.reg .f32 %ssa_19;
		mul.f32 %ssa_19, %ssa_12_1, %ssa_18; // vec1 32 ssa_19 = fmul ssa_12.y, ssa_18

		.reg .f32 %ssa_20;
		add.f32 %ssa_20, %ssa_19, %ssa_3;	// vec1 32 ssa_20 = fadd ssa_19, ssa_3

		.reg .f32 %ssa_21;
	mov.f32 %ssa_21, 0Fbe800000; // vec1 32 ssa_21 = load_const (0xbe800000 /* -0.250000 */)
		.reg .b32 %ssa_21_bits;
	mov.b32 %ssa_21_bits, 0Fbe800000;

		.reg .f32 %ssa_22;
		mul.f32 %ssa_22, %ssa_21, %ssa_20;	// vec1 32 ssa_22 = fmul ssa_21, ssa_20

		.reg .f32 %ssa_23;
	mov.f32 %ssa_23, 0Fbe19999a; // vec1 32 ssa_23 = load_const (0xbe19999a /* -0.150000 */)
		.reg .b32 %ssa_23_bits;
	mov.b32 %ssa_23_bits, 0Fbe19999a;

		.reg .f32 %ssa_24;
		mul.f32 %ssa_24, %ssa_23, %ssa_20;	// vec1 32 ssa_24 = fmul ssa_23, ssa_20

		.reg .f32 %ssa_25;
		add.f32 %ssa_25, %ssa_2_0, %ssa_22; // vec1 32 ssa_25 = fadd ssa_2.x, ssa_22

		.reg .f32 %ssa_26;
		add.f32 %ssa_26, %ssa_2_1, %ssa_24; // vec1 32 ssa_26 = fadd ssa_2.y, ssa_24

		.reg .f32 %ssa_27_0;
		.reg .f32 %ssa_27_1;
		.reg .f32 %ssa_27_2;
		.reg .f32 %ssa_27_3;
		mov.f32 %ssa_27_0, %ssa_25;
		mov.f32 %ssa_27_1, %ssa_26;
		mov.f32 %ssa_27_2, %ssa_3;
		mov.f32 %ssa_27_3, %ssa_1; // vec4 32 ssa_27 = vec4 ssa_25, ssa_26, ssa_3, ssa_1

		.reg .b64 %ssa_28;
	mov.b64 %ssa_28, %Ray; // vec1 32 ssa_28 = deref_var &Ray (shader_call_data RayPayload) 

		.reg .b64 %ssa_29;
	add.u64 %ssa_29, %ssa_28, 0; // vec1 32 ssa_29 = deref_struct &ssa_28->ColorAndDistance (shader_call_data vec4) /* &Ray.ColorAndDistance */

		st.global.f32 [%ssa_29 + 0], %ssa_27_0;
		st.global.f32 [%ssa_29 + 4], %ssa_27_1;
		st.global.f32 [%ssa_29 + 8], %ssa_27_2;
		st.global.f32 [%ssa_29 + 12], %ssa_27_3;
// intrinsic store_deref (%ssa_29, %ssa_27) (15, 0) /* wrmask=xyzw */ /* access=0 */


		// succs: block_3 
		// end_block block_1:
		bra end_if_5;
	
	else_5: 
		// start_block block_2:
		// preds: block_0 
		.reg .b64 %ssa_30;
	mov.b64 %ssa_30, %Ray; // vec1 32 ssa_30 = deref_var &Ray (shader_call_data RayPayload) 

		.reg .b64 %ssa_31;
	add.u64 %ssa_31, %ssa_30, 0; // vec1 32 ssa_31 = deref_struct &ssa_30->ColorAndDistance (shader_call_data vec4) /* &Ray.ColorAndDistance */

	st.global.f32 [%ssa_31 + 0], %ssa_0_0;
	st.global.f32 [%ssa_31 + 4], %ssa_0_1;
	st.global.f32 [%ssa_31 + 8], %ssa_0_2;
	st.global.f32 [%ssa_31 + 12], %ssa_0_3;
// intrinsic store_deref (%ssa_31, %ssa_0) (15, 0) /* wrmask=xyzw */ /* access=0 */


		// succs: block_3 
		// end_block block_2:
	end_if_5:
	// start_block block_3:
	// preds: block_1 block_2 
	// succs: block_4 
	// end_block block_3:
	// block block_4:
	shader_exit:
	ret ;
}
